{
    "collab_server" : "",
    "contents" : "#' Find min.prob threshold maximizing dev SR\n#'\n#' @param y.train : factor with levels -1, 1\n#' @param y.dev  : factor with levels -1, 1\n#' @param train.probs  : matrix with 2 columns: first is probability of up, second is down\n#' @param dev.probs : matrix with 2 columns: first is probability of up, second is down\n#'\n#' @return Named numeric containing the results of the best value for min.prop: c(min.prob, train.accuracy, train.freq, train.sr, dev.accuracy, dev.freq, dev.sr\n#' @export\n#'\nbest.min.prob <- function(y.train, y.dev, train.probs, dev.probs){\n  stopifnot(ncol(train.probs)==2 & ncol(dev.probs)==2)\n  stopifnot(length(y.train)==nrow(train.probs) & length(y.dev)==nrow(dev.probs))\n  stopifnot(all.equal(levels(y.train), levels(y.dev), c(-1,1)))\n\n  min.prob.seq <- seq(0.5, 1, 0.01)\n  max.sr <- -99\n  for(min.prob in min.prob.seq){\n    dev.preds <- 1*((dev.probs[,1]>min.prob) - (dev.probs[,2]>min.prob))\n    buy <- which(dev.preds==1)\n    sell <- which(dev.preds==-1)\n\n    if(length(sell)+length(buy) >0){ # Check that number of predictions > 0\n      dev.accuracy <- (sum(y.dev[sell]==-1)+sum(y.dev[buy]==1))/(length(sell)+length(buy))\n      dev.freq <- (length(buy)+length(sell))/length(dev.preds)\n      dev.sr <- freq.adjusted.accuracy(p=dev.accuracy, q=dev.freq, m=(7.5-2)*60, n)\n    } else { # if no predictions are made, break the loop\n      #cat(\"Zero predictions made with min.prob =\", min.prob, \"\\n\")\n      break\n    }\n    if(dev.sr>max.sr){ # if the parameter is the best so far, save the results\n      #cat(\"New best min.prob:\", min.prob, \"with SR=\", dev.sr, \"\\n\")\n      max.sr <- dev.sr\n      best.results <- c(min.prob=min.prob,\n                        train.accuracy=NA, train.freq=NA, train.sr=NA,\n                        dev.accuracy=dev.accuracy, dev.freq=dev.freq, dev.sr=dev.sr)\n    }\n  }\n  # Evaluate model on training sample\n  train.preds <- 1*((train.probs[,1]>best.results[\"min.prob\"]) - (train.probs[,2]>best.results[\"min.prob\"]))\n  buy <- which(train.preds==1)\n  sell <- which(train.preds==-1)\n  hold <- which(train.preds==0)\n  train.accuracy <- (sum(y.train[sell]==-1)+sum(y.train[buy]==1))/(length(sell)+length(buy))\n  train.freq <- (length(buy)+length(sell))/length(train.preds)\n  train.sr <- freq.adjusted.accuracy(p=train.accuracy, q=train.freq, m=(7.5-2)*60, n)\n  best.results[c(\"train.accuracy\", \"train.freq\", \"train.sr\")] <- c(train.accuracy, train.freq, train.sr)\n  return(best.results)\n}\n",
    "created" : 1527859218783.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2033731258",
    "id" : "6CF43AF1",
    "lastKnownWriteTime" : 1527859228,
    "last_content_update" : 1527859228667,
    "path" : "C:/Users/catti/Google Drive/Thesis/data_analysis/packages/thesis.resources/R/best.min.prob.R",
    "project_path" : "R/best.min.prob.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
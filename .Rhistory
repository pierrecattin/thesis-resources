#' \code{compute.indicators} computes technical indicators based on OLHCV prices series
#'
#' @param prices OLHCV prices series; xts
#' @param horizon For this number of observations in the end of each day, the indicator won't be computed (because no prediction can be made anyways); numeric
#'
#' @return xts with one column per technical indicator. Index is same as index of prices.
compute.indicators <- function(prices, horizon){
all.days <- as.Date(time(prices))
days <- unique(all.days)
n.obs.daily <- sum(all.days==all.days[1])
indicators <- matrix(NA, ncol=17, nrow=nrow(prices))
colnames(indicators)<- c("rsi.10", "rsi.60", "rsi.120",
"macd.5.10", "macd.8.20", "macd.15.30", "macd.28.60", "macd.40.100", "macd.70.120",
"wpr.10", "wpr.60", "wpr.120",
"return.1", "return.5", "return.10", "return.60", "return.120")
indicators <- as.xts(indicators, order.by=time(prices))
# d <- days[1]
for (d in days){
prices.day <- prices[all.days==d,]
#prices.day[(nrow(prices.day)-horizon):nrow(prices.day),] <- NA # remove obervations that are not relevant, because no prediction can be made
if (nrow(prices.day) != n.obs.daily){
warning(paste0("The number of observations on the ", d," is different from the other days. This day will be ignored"))
} else{
#RSI
indicators[all.days==d,]$rsi.10[1:(nrow(prices.day)-horizon)] <- as.numeric(RSI(prices.day$close, 10))[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$rsi.60[1:(nrow(prices.day)-horizon)]  <- as.numeric(RSI(prices.day$close, 60))[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$rsi.120[1:(nrow(prices.day)-horizon)] <- as.numeric(RSI(prices.day$close, 120))[1:(nrow(prices.day)-horizon)]
# MACD
indicators[all.days==d,]$macd.5.10[1:(nrow(prices.day)-horizon)] <-  (as.numeric(MACD(prices.day$close, nfast=5, nSlow=10, nSig=1)[,1])/prices.day$close)[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$macd.8.20[1:(nrow(prices.day)-horizon)] <-  (as.numeric(MACD(prices.day$close, nfast=8, nSlow=20, nSig=1)[,1])/prices.day$close)[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$macd.15.30[1:(nrow(prices.day)-horizon)] <-  (as.numeric(MACD(prices.day$close, nfast=15, nSlow=30, nSig=1)[,1])/prices.day$close)[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$macd.28.60[1:(nrow(prices.day)-horizon)] <-  (as.numeric(MACD(prices.day$close, nfast=28, nSlow=60, nSig=1)[,1])/prices.day$close)[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$macd.40.100[1:(nrow(prices.day)-horizon)] <-  (as.numeric(MACD(prices.day$close, nfast=40, nSlow=100, nSig=1)[,1])/prices.day$close)[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$macd.70.120[1:(nrow(prices.day)-horizon)] <-  (as.numeric(MACD(prices.day$close, nfast=70, nSlow=120, nSig=1)[,1])/prices.day$close)[1:(nrow(prices.day)-horizon)]
# WPR
indicators[all.days==d,]$wpr.10[1:(nrow(prices.day)-horizon)] <- as.numeric(WPR(prices.day[, c("high", "low", "close")], n=10))[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$wpr.60[1:(nrow(prices.day)-horizon)] <- as.numeric(WPR(prices.day[, c("high", "low", "close")], n=60))[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$wpr.120[1:(nrow(prices.day)-horizon)] <- as.numeric(WPR(prices.day[, c("high", "low", "close")], n=120))[1:(nrow(prices.day)-horizon)]
# returns
indicators[all.days==d,]$return.1[1:(nrow(prices.day)-horizon)] <- ROC(as.numeric(prices.day$close), n=1, type="discrete")[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$return.5[1:(nrow(prices.day)-horizon)] <- ROC(as.numeric(prices.day$close), n=5, type="discrete")[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$return.10[1:(nrow(prices.day)-horizon)] <- ROC(as.numeric(prices.day$close), n=10, type="discrete")[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$return.60[1:(nrow(prices.day)-horizon)] <- ROC(as.numeric(prices.day$close), n=60, type="discrete")[1:(nrow(prices.day)-horizon)]
indicators[all.days==d,]$return.120[1:(nrow(prices.day)-horizon)] <- ROC(as.numeric(prices.day$close), n=120, type="discrete")[1:(nrow(prices.day)-horizon)]
}
}
return(indicators)
}
roxygen2::roxygenise("thesis.resources")
roxygen2::roxygenise()
roxygen2::roxygenise()
library(thesis.resources)
library(thesis.resources)
compute.indicators()
?roxygenise
?roxygen2
roxygen2::roxygenise(load_code=thesis.resouces)
roxygen2::roxygenise(load_code=source_package)
roxygen2::roxygenise(load_code="/thesis.resources/R/thesis.resources.R")
View(compute.price.direction)
library(thesis.resources)
library(thesis.resources)
install.packages("RTools")
install.packages("devtools")
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
?compute.indicators
compute.indicators()
rm(list=ls()); gc()
setwd("C:/Users/catti/Google Drive/Thesis/data_analysis/thesis.main")
source("non.function.resources/load_packages.R")
source("non.function.resources/import.R")
horizon <- 10
indicators <- compute.indicators(prices, horizon)
library(thesis.resources)
compute.indicators()
#' Compute Price Direction
#' Computes a variable describing the direction of future price changes
#'
#' @param prices xts where one numeric column has to be called "close"
#' @param daily.start which observation number should be the first one for which the variable is computed each day; numeric
#' @param horizon prediction horizon; numeric
#' @param min.return  minimum absolute return in horizon to be classified as -1 or +1; default=0; numeric
#'
#' @return xts with one numeric (values -1, 0, +1, NA) column and same indices as prices. last 'horizon' values of each day are NA
#' @export
#'
compute.price.direction <- function (prices, daily.start, horizon, min.return=0){
all.days <- as.Date(time(prices))
days <- unique(all.days)
y <- prices$close
colnames(y)<-"movement"
y$movement <- NA
n.obs.daily <- sum(all.days==all.days[1])
# d <- days[1]
for (d in days){
closes <- prices[all.days==d,]$clos
if (nrow(closes) != n.obs.daily){
warning(paste0("The number of observations on the ", d," is different from the other days. This day will be ignored"))
} else{
future.closes <- c(rep(NA, daily.start-1),
as.numeric(closes[(daily.start+horizon):nrow(closes),]),
rep(NA, horizon))
up <- 1*(future.closes>=closes*(1+min.return))
down <- 1*(future.closes<closes*(1-min.return))
y$movement[all.days==d,] <- up - down
}
}
return(y)
}
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
?CCI
libary(TTR)
library(TTR)
?CCI
library(TTR)
N <- 20
returns <- c(NA, rnorm(N-1)/30)
prices <- c(100, rep(NA, N-1))
for (t in 2:N){
prices[t] <- round(prices[t-1] * (1+returns[t]),1)
}
plot(prices, type="l")
ema <- EMA(prices, H)
N <- length(prices)
H <- 4
ema <- EMA(prices, H)
plot(prices)
line(EMA)
plot(prices, type="l")
lines(EMA)
plot(prices, type="l")
library(thesis.resources)
data(iris3)
train <- rbind(iris3[1:25,,1], iris3[1:25,,2], iris3[1:25,,3])
train
summary(iris3)
summary(iris3[,,1])
View((iris3[,,1]))
View((iris3[,,2]))
train <- rbind(iris3[1:25,,1], iris3[1:25,,2], iris3[1:25,,3])
train
test <- rbind(iris3[26:50,,1], iris3[26:50,,2], iris3[26:50,,3])
cl <- factor(c(rep("s",25), rep("c",25), rep("v",25)))
cl
train <- rbind(iris3[1:25,,1], iris3[1:25,,2], iris3[1:25,,3])
test <- rbind(iris3[26:50,,1], iris3[26:50,,2], iris3[26:50,,3])
cl <- factor(c(rep("s",25), rep("c",25), rep("v",25)))
dim(train)
dim(test)
dim(train)
dim(test)
dim(cl)
length(cl)
train <- rbind(iris3[1:25,,1], iris3[1:25,,2], iris3[1:25,,3])
test <- rbind(iris3[26:40,,1], iris3[26:40,,2], iris3[26:40,,3])
cl <- factor(c(rep("s",25), rep("c",25), rep("v",25)))
dim(train)
dim(test)
length(cl)
knn3Train(train, test, cl, k = 5, prob = TRUE)
library(caret)
knn3Train(train, test, cl, k = 5, prob = TRUE)
library(thesis.resources)
max.lag=120
library(thesis.resources)
2/sqr(2)
2/sqrt(2)
sqrt(2)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
?misssing
?missing
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
library(thesis.resources)
?stopif
libary(MASS)
library(MASS)
x<- matrix(rnorm(1000*5), ncol=5)
x<- matrix(rnorm(1000*5), ncol=5)
y <- rowSums(x)>0
plot(y, x[,1])
x<- matrix(rnorm(1000*3), ncol=3)
y <- rowSums(x)>0
plot(y, x[,1])
plot(y, x[,1])
plot(y, rowSums(x))
plot(y, x[,1])
stopifnot(nrow(x) == length(y))
nrow(x) == length(y)
data <- cbind(y, x)
data
head(data)
x<- matrix(rnorm(1000*3), ncol=3)
y <- x[,1]+2*x[,2]-x[,3]>0
plot(y, x[,1])
plot(y, x[,3])
plot(y, x[,2])
table(y)
y <- 1*(x[,1]+2*x[,2]-x[,3]>0)
plot(y, x[,2])
table(y)
data <- cbind(y, x)
dim(data)
prior <- rep(0.5,2)
prior
probs <- lda(data[,1]~., prior)
ncol(data)
colnames(data)
colnames(data)[1]<-"y"
probs <- lda(y~., data=data, prior=prior)
data <- data.frame(data)
colnames(data)[1]<-"y"
colnames(data)
colnames(data)<-c("y", colnames(x))
colnames(data)
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
colnames(x)<-1:3
x<- matrix(rnorm(1000*3), ncol=3)
colnames(x)<-1:3
y <- 1*(x[,1]+2*x[,2]-x[,3]>0)
plot(y, x[,2])
table(y)
colnames(x)
x<- matrix(rnorm(1000*3), ncol=3)
colnames(x)<-paste0("model_",1:3)
colnames(x)
y <- 1*(x[,1]+2*x[,2]-x[,3]>0)
plot(y, x[,2])
table(y)
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
colnames(data)<
colnames(data)
colnames(data)
prior <- rep(0.5,2)
probs <- lda(y~., data=data, prior=prior)
probs
x<- matrix(rnorm(100000*3), ncol=3)
colnames(x)<-paste0("model_",1:3)
y <- 1*(x[,1]+2*x[,2]-x[,3]>0)
plot(y, x[,2])
table(y)
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
probs <- lda(y~., data=data, prior=prior)
probs
lda.fit <- lda(y~., data=data, prior=prior)
lda.fit
probs <- lda.fit$means
lda.fit
lda.fit$terms
lda.fit$call
lda.fit
attr(lda.fit)
attr(lda.fit, "coeffs")
lda.fit$class
probs <- predict(lda.fit, newdata=x)
probs <- predict(lda.fit, newdata=data.frame(x))
probs
x<- matrix(rnorm(100000*3), ncol=3)
colnames(x)<-paste0("model_",1:3)
y <- 1*(x[,1]+2*x[,2]-x[,3]>0)
plot(y, x[,2])
table(y)
x<- matrix(rnorm(10000*3), ncol=3)
colnames(x)<-paste0("model_",1:3)
y <- 1*(x[,1]+2*x[,2]-x[,3]>0)
plot(y, x[,2])
table(y)
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
probs <- predict(lda.fit, newdata=data.frame(x))
probs <- predict(lda.fit, newdata=data.frame(x))$posterior
head(posterior)
head(probs)
coeffs <- lda.fit
lda.fit$scaling
coeffs <- lda.fit$scaling
coeffs
sum(coeffs)
rowSums(probs)
coeffs
matrix(coeffs, ncol=1)
probs2 <- x %*% matrix(coeffs, ncol=1)
head(probs2)
head(probs)
y <- (x[,1]+2*x[,2]-x[,3]>0)*2-1
y
x<- matrix(rnorm(10000*3), ncol=3)
colnames(x)<-paste0("model_",1:3)
y <- (x[,1]+2*x[,2]-x[,3]>0)*2-1
plot(y, x[,2])
table(y)
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
probs <- predict(lda.fit, newdata=data.frame(x))$posterior
head(probs)
probs <- predict(lda.fit, newdata=data.frame(x))$posterior[,2:1]
head(probs)
yhat <- probs[,1]>0.5
yhat <- probs[,1]>=0.5
yhat <- 1*(probs[,1]>=0.5)
head(yhat)
yhat <- (probs[,1]>=0.5)*2-1
yhat
sum(yhat!=y)
sum(yhat!=y)/length(y)
x<- matrix(rnorm(10000*4), ncol=4)
colnames(x)<-paste0("model_",1:3)
y <- (x[,1]+2*x[,2]-x[,3]>0-4*x[,4]>0))*2-1
y <- ((x[,1]+2*x[,2]-x[,3]-4*x[,4])>0)*2-1
y
plot(y, x[,2])
plot(y, x[,4])
table(y)
x<- matrix(rnorm(10000*4), ncol=4)
colnames(x)<-paste0("model_",1:3)
y <- ((x[,1]+2*x[,2]-x[,3]-4*x[,4])>0)*2-1
plot(y, x[,4])
x<- matrix(rnorm(10000*4), ncol=4)
colnames(x)<-paste0("model_",1:4)
y <- ((x[,1]+2*x[,2]-x[,3]-4*x[,4])>0)*2-1
plot(y, x[,4])
table(y)
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
probs <- predict(lda.fit, newdata=data.frame(x))$posterior[,2:1]
yhat <- (probs[,1]>=0.5)*2-1
sum(yhat!=y)/length(y)
coeffs <- lda.fit$scaling
coeffs
plot(lda.fit)
plot(lda.fit)
plot(lda.fit, type="both")
library(klaR)
install.packages("klaR")
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
partimat(y~.,data=data,method="lda")
library(klaR)
partimat(y~.,data=data,method="lda")
y
colnames(data)<-c("y", colnames(x))
partimat(y~.,data=data,method="lda")
x<- matrix(rnorm(100*4), ncol=4)
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
x<- matrix(rnorm(100*4), ncol=4)
colnames(x)<-paste0("model_",1:4)
y <- ((x[,1]+2*x[,2]-x[,3]-4*x[,4])>0)*2-1
plot(y, x[,4])
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
probs <- predict(lda.fit, newdata=data.frame(x))$posterior[,2:1]
probs
rowSums(probs)
coeffs <- lda.fit$scaling
coeffs
coeffs <- lda.fit
coeffs <- lda.fit$scaling
probs2 <- x %*% matrix(coeffs, ncol=1)
probs2
matrix(coeffs, ncol=1)
head(probs2)
head(probs)
lda.fit
x<- matrix(rnorm(100*4), ncol=2)
y <- ((x[,1]-2*x[,2])>0)*2-1
colnames(x)<-paste0("model_",1:ncol(x))
plot(y, x[,4])
plot(y, x[,2])
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
lda.fit
colMeans(x[y==1,])
colMeans(x[y==-1,])
y <- ((x[,1])>0)*2-1
x<- matrix(rnorm(100*4), ncol=1)
y <- ((x[,1])>0)*2-1
colnames(x)<-paste0("model_",1:ncol(x))
plot(y, x[,2])
plot(y, x[,1])
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
lda.fit
x<- matrix(rnorm(10000*4), ncol=1)
y <- ((x[,1])>0)*2-1
colnames(x)<-paste0("model_",1:ncol(x))
plot(y, x[,1])
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
lda.fit
1.657558*x
head(1.657558*x)
probs <- predict(lda.fit, newdata=data.frame(x))$posterior[,2:1]
haed(probs)
head(probs)
head(1.657558*x)
head(log(1.657558*x))
mean(x[y==1,])
mean(x[y==1,])/sd(x[y==1,])
lda.fit
mean(x[y==1,])/sd(x[y==1,])^2
mean(x[y==1,])/var(x[y==1,])
score <- x %*% matrix(coeffs, ncol=1)
x<- matrix(rnorm(10000*4), ncol=4)
y <- ((x[,1]+2*x[,2]-x[,3]-4*x[,4])>0)*2-1
colnames(x)<-paste0("model_",1:ncol(x))
plot(y, x[,1])
stopifnot(nrow(x) == length(y))
data <- cbind(y, x)
data <- data.frame(data)
colnames(data)<-c("y", colnames(x))
prior <- rep(0.5,2)
lda.fit <- lda(y~., data=data, prior=prior)
probs <- predict(lda.fit, newdata=data.frame(x))$posterior[,2:1]
coeffs <- lda.fit$scaling
score <- x %*% matrix(coeffs, ncol=1)
score
scores <- x %*% matrix(coeffs, ncol=1)
plot(scores, probs[,1])
plot(scores, probs[,1], type="l")
plot(scores, probs[,1])
plot(scores, probs[,2])
plot(scores, probs[,1])
library(bizdays)
years <- 2014:2017
start <- as.POSIXct(paste(min(years),"01-01", sep="-"))
end <- as.POSIXct("2018-04-30")
end
nyse.holidays <- timeDate::holidayNYSE(2000:2018)
create.calendar(name="NYSE", holidays=nyse.holidays, weekdays=c('saturday', 'sunday'))
end <- as.POSIXct("2017-12-31")
nyse.holidays <- timeDate::holidayNYSE(2000:2018)
create.calendar(name="NYSE", holidays=nyse.holidays, weekdays=c('saturday', 'sunday'))
days <- seq.POSIXt(as.POSIXct(start), end, by="day") # all the minutes in interval
days <- days[is.bizday(days, "NYSE")] # remove holidays
days <- as.Date(days)
days
tail(days
)
stock <- "AAPL"
nyse.open<-"09:30:00.000"
nyse.close<-"16:00:00.000"
prices <- data.frame(date=character(0),
time_trunc=character(0),
open=numeric(0),
high=numeric(0),
low=numeric(0),
close=numeric(0),
volume=numeric(0),
nb.trades=numeric(0),
stringsAsFactors = F)
